The critical part of including a block into a blockchain is the inclusion of a cryptographic hash of the previous block. In this way, blocks are linked all the way back to the very first genesis block and are verified by hashes. Because each block contains the previous hash and that gets hashed within the next block, in a sense, all the previous hashes are baked into all future block hashes. This is where the real immutability comes in. All the blocks are connected through the interrelationships of all their hashes. You can see here a sequence of blocks each with their associated data, hashes, and nonces. If anything is changed anywhere in the chain, there's a ripple effect invalidating all the blocks that come afterwards. Suppose a malicious person, Carl, was trying to alter our transaction on the chain. As we know, you can't just change data because that would create an invalid block, so you'd have to re-mine that block and find a nonce that yields a hash value below the target difficulty. Since all the following blocks must contain the hash of the previous block, all the following blocks would be invalidated as well. Only if Carl had an incredible near-impossible amount of computing power, would he be able to rebuild the whole chain to include his fraudulent transaction, and Carl doesn't have nearly that much computing power. That robustness is the power of the distributed blockchain, and why it's thought of as being incorruptible.